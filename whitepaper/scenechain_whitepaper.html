<!DOCTYPE html>
<html>
<head>
<title>Scenechain Whitepaper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 15px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  font-variant: small-caps;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 38px;
  color: #000;
}

h2 {
  font-size: 26px;
  color: #000;
}

h3 {
  font-size: 20px;
}

h4 {
  font-size: 18px;
}

h5 {
  font-size: 16px;
}

h6 {
  color: #777;
  font-size: 15px;
  font-style: italic;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 15px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 13px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 14px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}

/* CUSTOM
=============================================================================*/

p.info {
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
  padding: 6px 10px;
  font-size: 14px;
  color: #666;
}

p.manifesto {
  //line-height: 2;
  //border: 1px solid #eaeaea;
  //background-color: #f8f8f8;
  //border-radius: 3px;
  //padding: 6px 10px;
  //font-size: 16px;
  //font-weight: bold;
  //color: #666;
  //font-variant: small-caps;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

.sc {
  font-variant: small-caps;
}

h1 img  {
	width: 32px;
	height: 32px;
}

</style>
</head>
<body>

<h1><img src="schenechain_logo_twitter.png"/> Scenechain Whitepaper</h1>

<h6>v0.2.1 - Oct 23 2021</h6>



<p class="info">Please note that until the release of the <strong class="sc">Scenechain mainnet</strong> the <strong class="sc">Scenechain whitepaper</strong> should be considered under development.</p>
<p><strong class="sc">Scenechain</strong> is a collaborative generative-art NFT creation platform built on Solana. It is using:</p>
<ul>
<li><strong>composability</strong> to achieve collaboration</li>
<li><strong>code-space scarcity</strong> to incentivize both high quality and the use of composition</li>
</ul>
<p>The long-term vision of <span class="sc">Scenechain</span> is to make high-quality audiovisual generative art a store of value.   </p>

<h2>About generative art and the demoscene</h2>
<p>If you are not familiar with generative art and the demoscene this is an important chapter to understand this whitepaper. Otherwise, you can skip ahead to the <em><span class="sc">Scenechain</span> basics</em> chapter.</p>
<p>Quoting from Wikipedia:</p>
<blockquote>
<p>Generative art refers to art that in whole or in part has been created with the use of an autonomous system. ... it often refers to algorithmic art (algorithmically determined computer generated artwork) and synthetic media (general term for any algorithmically-generated media).</p>
</blockquote>
<p>There are 2 quite distinct communities involved with generative art: the more traditional art scene and the demoscene.</p>
<h3>Generative art in the art scene</h3>
<p>The generative art movement started to take off in the 1960s in the art scene. Artists used computers to generate art pieces. Here is an example from 1966:</p>
<p><figure align="center">
<img src="./nake-walk-through-raster.png"/>
<figcaption align="center"><b>Picture 1 - Walk Through Raster, Frieder Nake 1966</b></figcaption>
</figure></p>
<h3>The demoscene</h3>
<p>Quoting from Wikipedia:</p>
<blockquote>
<p>The demoscene: is an international computer art subculture focused on producing demos: self-contained, sometimes extremely small, computer programs that produce audiovisual presentations. </p>
</blockquote>
<p>The demoscene started in the early 1980s. In the demoscene, there are demo categories that artificially restrict the program size of the demos.
The most widespread categories are the 64Kbyte demos and the 4KByte demos. Because of the small code size, these artworks rely very heavily on algorithmic generation.
The most beautiful 64Kbyte or 4Kbyte demos are basically high-quality generative artworks.</p>
<p>This is one of the best 64kbyte demos of all time:</p>
<p><a href="https://www.youtube.com/watch?v=MAnhcUNHRW0" title="Chaos Theory by Conspiracy">https://www.youtube.com/watch?v=MAnhcUNHRW0</a></p>
<p>And here is one of the most amazing 4kbyte ones:</p>
<p><a href="https://www.youtube.com/watch?v=jB0vBmiTr6o" title="elevated by Rgba &amp; TBC">https://www.youtube.com/watch?v=jB0vBmiTr6o</a></p>

<h2>Scenechain basics</h2>
<p><span class="sc">Scenechain</span> demos work on a virtual demo machine which we call the <strong class="sc">Scenechain Virtual Machine</strong>, which is basically a webassembly virtual machine with some audio-visual APIs that are thin webassembly wrappers of browser APIs like <code>WebGL</code>, <code>Web-Audio</code> and the <code>Canvas API</code>.
In practice, <span class="sc">Scenechain</span> demos work in a web browser. </p>
<p>The <span class="sc">Scenechain</span> demo code lives in the <strong class="sc">Scenechain code space</strong>. The <span class="sc">Scenechain code space</span> is limited:
Anyone can upload code to the code space in a permissionless way, but it costs SCODE tokens to upload code. SCODE is a scarce deflationary asset.
This way creators are incentivized to achieve the desired audio-visual effect using as small code-size as possible. The created demos are NFTs that can be sold for Solana.</p>
<h2>Composability</h2>
<p>The above-mentioned mechanism would create an interesting NFT marketplace, but the secret sauce and core innovation of <span class="sc">Scenechain</span> are that it also incentivizes creative collaboration through composability (otherwise known by programmers as <em>code reuse</em>).
Creating useful reusable open-source code libraries always suffered from the <strong>tragedy-of-commons</strong> problem: people gain tremendous value from these libraries but their creators are not financially rewarded for it.
In <span class="sc">Scenechain</span> in order to create amazing demos with small code size, creators are incentivized to refer to other already uploaded code libraries and call functions from them,
because as we will see it is cheaper to refer to code than to duplicate it. The creators of the libraries are automatically rewarded when other creators reuse their code.
We will present an example in the next chapter on how this composability can be used to achieve great things using other people's work.
We believe that in the future it will also be used in ways that we cannot anticipate today.
</p>

<h2>Scenechain package basics</h2>
<p>Creators can upload so-called <strong class="sc">Scenechain packages</strong> to the <span class="sc">Scenechain code space</span>. A <span class="sc">Scenechain package</span> is a webassembly module plus a little metadata.</p>
<p>Package upload costs SCODE tokens: we will discuss the details of cost calculation later. <span class="sc">Scenechain packages</span> are immutable: once uploaded cannot be modified and are there forever.
The package is the unit of ownership in <span class="sc">Scenechain</span>. When a package is uploaded its uploader becomes its first owner. Packages can be traded as NFT-s.</p>
<p>A <span class="sc">Scenechain package</span> - being a webassembly module - contains webassembly <strong>functions</strong>. Some of these functions are declared <strong>exported functions</strong>.
An exported function in one package can be <strong>imported</strong> and called from any other (later) package in the code space: this is the way creators can reuse already uploaded code.</p>
<p class="info">
Note that exported and imported functions are not a <span class="sc">Scenechain</span> invention, they are part of the webassembly format, <span class="sc">Scenechain</span> just uses a naming convention that the package id (which is a Solana account id) is the name used as webassembly module name when importing.</p>
<p>A <span class="sc">Scenechain package</span> can be a <strong>demo</strong> or a <strong>library</strong>.
A demo can still contain exported functions, its only speciality is that it contains a function called <code>_play()</code> which is the entry point of the audio-visual demo.
Although the <code>_play()</code> function is exported to be accessed by the demo runtime, other packages can never import this function.
(The general rule is that any function with a name starting with the underscore character is exported for the runtime and cannot be imported by other packages.)</p>
<p><figure align="center">
<img src="./scenechain_packages.svg" alt="Scenechain packages referring to each other" />
<figcaption align="center"><b>Picture 2 - Scenechain packages referring to each other</b></figcaption>
</figure></p>
<p>
In the above diagram we can see a use-case with 3 libraries and 2 demos (one of which is not really a demo but a song).
The arrows represent imports in the direction of function call (the arrow goes from the importer to the exported function).
Eve is a composer who composed a song. She offers this song technically as a demo, because her package has a <code>_play()</code> function.
She is not a coder though: her package contains just a few lines of code and her compressed music. In the short code she calls Alice's library to decompress the music from the compressed representation stored in her package,
calls Carol's music visualizer to display something on the screen during the music and calls Bob's music player to play the music. In addition to this she exports a <code>get_song()</code> function so that demo coders
who are not composers can create demos based on her music. This is what Dave does with his demo: Uses Eve's music during his demo and also uses Bob's music player library to play the music.</p>
<h2>SCODE tokenomics</h2>
<p>SCODE is a standard spl token on Solana. Its token address is: <code>HWnfNCDHWJqqXQBpF379ubyLPhk8sdvFAa2mBsn4T6Bz</code></p>
<p>1,000,000,000 SCODE tokens has been minted in the beginning.
SCODE is a deflationary token, because as we will see a lot of it will be burnt when used, and no SCODE token is released besides the genesis 1,000,000,000 ever.</p>
<p>The cost of a package upload is calculated as follows:</p>
<pre><code>upload_cost = base_cost + dependency_cost
</code></pre>

<p><code>base_cost</code> is 1 SCODE for each byte using the <strong>net package size</strong>.</p>
<p class="info">
The net package size of a package is the size of the webassembly module inside the package minus the import and export sections plus 1 byte for each import and export.
The reason that we count the imports and exports as only one byte each is that these sections (and fortunately only these sections) contain the human-readable names of imported and exported functions.
(At other places only the function index is used inside binary webassembly). If we would count these sections into the cost as is, creators would use very short (minified) names, which would be confusing.
</p>
<p>98% of <code>base_cost</code> is simply burned, 2% is <code>operator_reward</code>. </p>
<p class="info">
operator_reward is payed to the operator of the webapp (or other kind of off-chain app) the user is directly interacting with to access <span class="sc">Scenechain</span>.
</p>
<h3>Dependency royalties</h3>
<p>Designing a good system to distribute royalties to dependencies is not trivial.
The problem is that if the system is designed in a naive way there will be profitable strategies to upload packages in a way that is not good for the ecosystem.
The most obvious of these behaviors is to create copycats of every interesting library.
If we design algorithms to discourage this then we get other kinds of more nuanced vulnerabilities like actors managing to pay lots of royalties to themselves.</p>
<p>We considered multiple complex systems to solve these problems purely with algorithms. Each of these systems has some drawbacks and some of them are very complicated.
Eventually, we decided to go with a relatively simple system and not only rely on algorithms but also on <strong>social contracts</strong> in the community. </p>
<p>First of all, <code>dependency_cost</code> is 0 for library packages. (packages that do not have a <code>_play()</code> function)</p>
<p>For demo packages, the <code>dependency_cost</code> is calculated based on the functions called from the <code>_play()</code> function of this package and the functions called by them recursively.
First, a list of all these called functions is assembled, which we call dependencies. Then for each such dependency, a cost contribution is calculated as the size of the function multiplied by a <code>p</code> quotient. </p>
<pre><code>dependency_cost = for_each_dependency_function_F(size(F) * p)
</code></pre>

<p>where </p>
<pre><code>p = 0.03 + (position_in_codespace(F) / current_filled_codespace_size) * 0.02
</code></pre>

<p>This cost is simply transferred to the owners of the dependency functions.</p>

<p>In addition to the math, the social contract used here is that the community values originality and reuse of original code where possible.
Any demo which has a library that has obvious copycats in their dependency tree will be worth less by NFT collectors than the ones that use the ecosystem as intended.
We will discuss <span class="sc">Scenechain</span> social contracts in more detail in the <em class="sc">Scenechain manifesto</em> chapter.   </p>

<h3>Implications of the dependency royalties calculation</h3>
<p>The mechanism above means that the cost of using a package is somewhere between 3% and 5% of its size.
The formula incentivizes the usage of functions earlier in the code space: besides the social contracts mentioned above,
this is also something that incentivizes original work instead of copycats.</p>
<p>This mechanism implies that it is profitable to publish a library if its functions will be called (directly or indirectly) from at least 20-33 demos on average.
(Actually, sometimes a package can be profitable with significantly less use because as we will see the dependencies of a package also get some royalties from package sales.)
Anyway, 20-33 usage can be easily achieved in the case of certain generic functions.
Also, note that if a creator needs to write a function for a demo anyway it might be a good idea to export it even if only 1 or 2 packages would use it.</p>

<h3>Tokenomics implications to the size of the code space</h3>
<p>Because 0.98 SCODE from the 1,000,000,000 SCODE is always burnt for each uploaded byte the maximum capacity of the code space is around 1 GByte.
The code space seems extremely scarce, and it is, but people familiar with 4Kbyte demos know what very creative people can achieve in small code sizes.
Also here the possibility to cheaply reuse other people's code means that we will see traditional 4Kbyte demo quality in much smaller sizes.
The decision for the 1,000,000,000 initial SCODE tokens was a tradeoff. We want to simulate Renaissance Florence:
There must be enough code space to have a vibrant ecosystem for the years to come and to be profitable in creating amazing art and useful libraries in the early years.
On the other hand, we need extreme scarcity for the conservative long-term art NFT collectors.</p>
<h3>NFT trading cost and royalties</h3>
<p>Once a package is uploaded it can be traded for SOL tokens. There is a 0.2% <code>trading_fee</code> involved which is paid to the operator (similarly to <code>operator_reward</code> in case of package upload). </p>
<p>We have seen that dependent functions get royalties from package uploads. There is also a mechanism that dependencies get a little bit of profit from high-value package sales. It works the following way:
For each package, its highest-ever sale price is recorded. (all-time-high price). When a package is sold for a new all-time high price, a bonus needs to be paid by the buyer.
This bonus is distributed among the dependencies of the package weighted using the already known weights (<code>size(F) * p</code>). The bonus is calculated as follows:
</p>
<pre><code>ath_royalty_bonus = (new_ath - previous_ath) * 0.05
</code></pre>
<h2>Scenechain manifesto</h2>
<p>The <span class="sc">Scenechain</span> community can thrive if most of the community members behave according to this manifesto:</p>
<br/>
<hr/>
<p class="manifesto">The ultimate goal of the <span class="sc">Scenechain</span> community is to protect the ability of valuable <span class="sc">Scenechain packages</span> to be a long-term store of value.</p>
<p class="manifesto">We believe that the above goal can be achieved through valuing innovation and collaboration.</p>
<p class="manifesto">We value the original instead of the copycat.</p>
<p class="manifesto">With regards to copycats, not all cases are black-and-white.</p>
<p class="manifesto">Because packages are immutable each package is responsible for the entirety of its dependency tree.</p>
</p>
<hr/>
<br/>
<p>Let's discuss the points:</p>
<blockquote>
<p>The ultimate goal of the <span class="sc">Scenechain</span> community is to protect the ability of valuable <span class="sc">Scenechain packages</span> to be a long-term store of value.</p>
</blockquote>
<p>Obviously, the value of SCODE tokens will be higher as a consequence of the success of the above goal but
the value of the SCODE token cannot be more important than the ability of quality packages to be a long-term stable store of value.
Without the packages having a stable long-term value SCODE tokens can only have vulnerable short-term speculative value.</p>
<blockquote>
<p>We believe that the above goal can be achieved through valuing innovation and collaboration.</p>
</blockquote>
<p>For this reason, <span class="sc">Scenechain</span> is designed to incentivize innovation and collaboration via composition. On the other hand, this must be done without violating our first point.
An example is the SCODE token supply. Higher supply might foster more innovation on a longer time horizon than the 1 billion supply but we needed a tradeoff here because we need significant scarcity to achieve our first goal.</p>
<blockquote>
<p>We value the original instead of the copycat.</p>
</blockquote>
<p>Original ideas first introduced to Scenechain should be valued highly. Both when investing and also when importing. 
When someone blatantly copies and reuploads a library already on <span class="sc">Scenechain</span> (maybe changing trivialities to make it harder to notice the duplication) we call such a package (or part of a package) a copycat.
Copycat authors might advertise their package both for investment and for importing.
If they could succeed it would demotivate other authors to create original content. We envision that the community will create tools and databases where those packages can be flagged (with explanation).</p>
<blockquote>
<p>With regards to copycats, not all cases are black-and-white</p>
</blockquote>
<p>We don't like when an exported function is just copied instead of imported from a new package. On the other hand, if the function is not exported but solves an important general problem, it should be ok to copy.
(Example: Someone writes a nice short generic function to do Fast Fourier Transform on sound data inside a demo, but they do not export the function. Other people should copy and export it then.)
But just copying every private function of a demo and publishing a very similar demo is not valuable. </p>
<p>Some copies have some improvements on the original, in this case, it is also ok to copy, but it can be a fine line.
We certainly don't ban anything and we can value things just a little bit more or a little bit less, we don't need black and white judgment all the time.</p>
<blockquote>
<p>Because packages are immutable each package is responsible for the entirety of its dependency tree.</p>
</blockquote>
<p>When importing a function from a package we should examine that package the same way as when we buy a package.
Importing a blatant copycat makes the importer package also less valuable because 'unpunished' this behavior would lead to profitable unproductive behaviour by copycat creators.</p>
<p>As we mentioned there will be databases where creators can check whether a library has been flagged as a copycat suspect or not.
Still, it will probably happen that someone will import from a copycat accidentally.
This should not render the importer package worthless, just a little bit less worthy.
Human judgment is important in these cases, these are things that would be hard to solve only with algorithms.</p>

<h2>Scenechain off-chain code overview</h2>
<p>The <span class="sc">Scenechain</span> on-chain code is responsible for the management of package uploads, cost calculation, royalty distribution, and NFT trading.
It never actually executes the webassembly code inside the packages. The webassembly code is executed off-chain in the browser (or any environment that adheres to the <em class="sc">Scenechain Virtual Machine Specification</em>).
Similarly to the on-chain code the <span class="sc">Scenechain</span> off-chain codebase is open-source.
It contains a web application in which users can upload, browse and trade packages, and run demos.
The web app will be run by the <span class="sc">Scenechain</span> team, but anyone else can run the web app parallelly.
Also, anyone can create similar web apps: it is not part of the <span class="sc">Scenechain protocol</span>.
Strictly speaking, the <span class="sc">Scenechain protocol</span> consists of the on-chain code and the <em class="sc">Scenechain Virtual Machine Specification</em>.
(For example, this specification will contain the audio-visual APIs available for the demos.)
The <span class="sc">Scenechain</span> off-chain code can be treated as a <strong>reference implementation</strong> of the off-chain parts of the protocol.</p>
<p>The <span class="sc">Scenechain</span> web app is a blockchain explorer and a lightweight development environment. It provides the following capabilities to the users:</p>
<ul>
<li>Users can browse packages in the order of upload. It is possible to filter for certain attributes like code size.</li>
<li>It is possible to run the demos.</li>
<li>The webassembly code in packages can be viewed converted to textual webassembly.</li>
<li>Possibly we will store other optional information off-chain for packages and they can be also viewed. (Example: source code if the code was compiled from a higher-level language, Readme file, etc...)</li>
<li>Creators can author and upload new packages. Also, they can test the packages before uploading.  </li>
</ul>

<h2>Smart contract tech details</h2>
<p>Writing smart contracts for tasks that handle a relatively large amount of data or do a non-trivial amount of calculation is not a simple feat on any blockchain.
Solana has remarkable throughput but the fixed calculation limit in an instruction and the fixed account data size limit need careful consideration about how we arrange data and calculations to always fit into the limits.</p>
<p>From the data-access perspective, the Solana blockchain can be treated as a key-value store: Programs can own any number of accounts: the account's public key is the key, and the data stored in an account is the value.</p>
<p><span class="sc">Scenechain</span> will create one account for each uploaded package. Each package will contain its own position in bytes in the <span class="sc">Scenechain code space</span>.</p>
<p>There will be an additional global Solana account to store global information such as:</p>
<ul>
<li>position in bytes in the code space of the last-added package</li>
<li>the public key of the last-added package</li>
</ul>
<p>On Solana SOL needs to be paid for an account creation if we want the account to be rent-exempt forever.
Luckily this cost is not too big for the data size we deal with in the case of <span class="sc">Scenechain</span>. The package uploader will have to pay this SOL fee in addition to the SCODE cost of an upload.  </p>

<h3>Dependency royalty calculation in the smart contracts</h3>

<p>
The most resource-intensive calculation that needs to be executed in smart contracts is the calculation of royalties. This wouldn't even be feasible on most other chains but needs an optimized
algorithm even on Solana to scale to complex Scenechain packages with large dependency trees.
</p>

<p>
The naive approach would be recursively traversing the whole dependency tree of a new package (using depth-first search for example) in one transaction. This would be prohibitive: we would need to process
a huge amount of packages in one transaction.
</p>

<p>
What we do instead is that we precalculate the set of transitive dependencies of each function when its package is uploaded. A package upload will consist of several transactions:
</p>

<pre><code>actual_package_upload()
precalc_deps(F1)
precalc_deps(F2)
...
commit_package()
</code></pre>

<p>
So the key smart contract function is <code>precalc_deps(F)</code>. It will simply take the precalculated dependency set of the functions called from <code>F</code>, unions them together, and stores the result as
the precalculated dependency set of <code>F</code>. 
</p>

<p>
The above-mentioned algorithm would be fast but would need significant storage for the precalculated dependency sets, so there is one more optimization: we only store the hash of the precalculated dependency set
for each function in the blockchain. The actual dependency sets of the functions called by <code>F</code> have to be provided by the off-chain code to the <code>precalc_deps(F)</code> function. (The smart contract
checks whether they are correct by comparing their hash to the stored hash.)
</p>

<h2>Scenechain Virtual Machine and web app tech details</h2>
<p><span class="sc">Scenechain</span> demo developers will need to create packages that contain webassembly functions which will run
in the browser in a sandboxed environment.
In these functions, they will be able to use the <strong class="sc">Scenechain Demo API</strong>. The <span class="sc">Scenechain Demo API</span> contains
the low-level functions to create visuals and sound effects programmatically, and also will
contain functions to gain user input to be able to create interactive experiences. The <span class="sc">Scenechain</span> Demo API will
be mostly a thin wrapper around <code>WebGL</code>, <code>Web-Audio</code>, and the <code>Canvas API</code> which we will expose from the embedding Javascript environment.
The webassembly code will be heavily sandboxed: not being able to access anything which is not part of the <span class="sc">Scenechain Demo API</span>.</p>
<p>The demos can decide the viewport size they use and they can communicate this to the embedding environment, so the embedding environment may decide what resolution it uses during playback.
Demos are encouraged to use the <strong>1080p</strong> resolution today, but this is not a requirement in the protocol, as the community may decide to prefer higher resolutions in the case of later demos.</p>
<p>The smart contracts do not and cannot decide whether a webassembly demo is buggy or not. People will simply not collect demos that are deemed not worthy.
The client code only needs to ensure that sandboxing works well and the web app does not hang when the webassembly code is not responsive.    </p>
<p>The <span class="sc">Scenechain</span> web app will be developed using Nodejs and Javascript on the server-side. In the browser, we will use Reactjs with Javascript.</p>
<p>Please note that the webassembly modules in the packages cannot be used as they are in the browser.
They lack the <span class="sc">Scenechain Demo API</span> imports and also only one module can be executed at one time in the browser.
For this reason, when running a demo package, the web app will recursively download all its dependencies, and merge them into an <strong>executable</strong> webassembly module.
In the case of the packages in <code>Picture 2</code>, if we want to run the demo <code>Dave's awesome demo</code>, all the packages on the picture will be downloaded and merged. During the merge, the following happens:</p>
<ul>
<li>All the functions in all the packages are appended together</li>
<li>Intermediary exports and imports are eliminated, the only exports remaining are the exports of the demo package starting with an underscore.</li>
<li>Function indices are reshuffled (for example in call instructions)</li>
<li>Imports are added from the embedding environment to support the <span class="sc">SceneChain Demo API</span>.</li>
</ul>

<h2>Roadmap</h2>

<p>Happended so far:</p>

<ul>
<li>September 2021: The start of Scenechain development</li>
<li>Oktober 25, 2021: The 1,000,000,000 SCODE tokens have been minted</li>
</ul>

<p>Future plans:</p>

<ul>
<li>November 2021: airdrops and token sale(s)</li>
<li>March 2021: Mainnet release</li>
</ul>

<h2>Development Roadmap</h2>
<p>Before the mainnet release, the main focus is on creating robust fundamentals on which the team and the community can build.
The UX will be a bit bare-bones and the only programming language supported will be textual webassembly.
Some of the efforts will be partly parallelized, but the rough order is the following:</p>
<ul>
<li>Webassembly format operations (like merging packages)</li>
<li>Smart contract development</li>
<li><span class="sc">Scenechain Demo API</span> development</li>
<li>Webapp development</li>
</ul>
<p>After the mainnet release, we can concentrate more on higher-level convenience features which are implemented in off-chain code. Examples:</p>
<ul>
<li>good development environment UX</li>
<li>possibly using higher level languages. </li>
<li>library discoverability features   </li>
</ul>
<h2>Token allocation</h2>
<ul>
<li>25% - Team allocation</li>
<li>25% - Airdrops</li>
<li>25% - Seed funds and/or public sale</li>
<li>25% - Ecosystem funds</li>
</ul>

<h3>Team allocation</h3>

<p>
Part of it (16%) gradually unlocks over 3 years for existing team members. Part of it (9%) is reserved for future team members.
For existing team members the 3 year lock period will start before the public token sales.
</p>

<h3>Seed funds and/or Public sale</h3>

<p>
Funds collected from this will be used for <strong class="sc">Scenechain</strong> development.
</p>

<h3>Airdrops</h3>

<p>
Some airdrop campaigns will happen before the public sale and some will happen after it.
In the airdrop campaigns before the public sale, people will be able to apply for tokens, but those tokens will be actually airdropped
only after the public sale. This way airdropped funds will not participate in the initial price discovery of SCODE.
</p>

<h3>Ecosystem funds</h3>

<p>
Grants will be decided by the <strong class="sc">Scenechain</strong> team in the beginning. Eventually, grants will be decided by a decentralized governance mechanism. 
</p>

</body>
</html>
